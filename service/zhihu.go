package service

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
)

type Question struct {
	Title string `json:"title"`
	URL   string `json:"url"`
}

type HotList struct {
	Data []Question `json:"data"`
}

type AutoGenerated struct {
	Data []struct {
		Target struct {
			ID      int    `json:"id"`
			Title   string `json:"title"`
			Excerpt string `json:"excerpt"`
		} `json:"target"`
	} `json:"data"`
}

type Output struct {
	Title string
	URL   string
}

func ZhiHuHotList() {
	url := "https://www.zhihu.com/api/v3/feed/topstory/hot-lists/total?limit=50&desktop=true"

	res, err := http.Get(url)
	if err != nil {
		panic(err)
	}

	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		panic(err)
	}

	var hotList AutoGenerated
	err = json.Unmarshal(body, &hotList)
	if err != nil {
		panic(err)
	}

	// 生成HTML代码
	var html string
	html += "<html><body><ol>"
	for _, v := range hotList.Data {
		html += "<li><a href=\"" + fmt.Sprintf("https://www.zhihu.com/question/%d", v.Target.ID) + "\">" + v.Target.Title + "</a></li>"
	}
	html += "</ol></body></html>"

	SendEmail(html)

}

// 雪球热帖
func XueQiuHotList2() {
	url := "https://tophub.today/n/RrvWOwRv5z"

	// 发送 GET 请求获取页面内容
	resp, err := http.Get(url)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	// 读取页面内容
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	fmt.Println(string(body))
	// 使用正则表达式匹配页面中的贴子标题
	re := regexp.MustCompile(`title="(.*?)"`)
	matches := re.FindAllStringSubmatch(string(body), -1)

	// 输出前 20 条贴子标题
	for i := 0; i < 20 && i < len(matches); i++ {
		fmt.Println(matches[i][1])
	}

}

type Topic struct {
	Title string
	URL   string
}

func XueQiuHotList() {
	url := "https://xueqiu.com"
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()

	// 读取页面内容
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	re := regexp.MustCompile(`<a href="/(\w+)/(\d+)" class="home-trending-stocks__item__name"`)
	matches := re.FindAllStringSubmatch(string(body), 20)
	fmt.Println(string(body))

	for _, match := range matches {
		topic := match[1]
		url := fmt.Sprintf("%s/%s/%s", url, topic, match[2])
		fmt.Printf("Topic: %s, URL: %s\n", topic, url)
	}
}
